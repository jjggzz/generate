// Code generated by sqlxgen. DO NOT EDIT.
package {{.PackageName}}

import (
    "database/sql"
	"github.com/jmoiron/sqlx"
	"strings"
)

type {{StrFirstLetterToLowercase .EntityName}}Repo struct {
    db *sqlx.DB
}

// execute fail return -1 and err
// execute success return count rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) Count() (int64, error) {
   var count int64
   	err := repo.db.Get(&count, "select count(*) from {{.TableName}}")
   	if err != nil {
   		return -1, err
   	}
   	return count,nil
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) Insert({{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := repo.db.Exec("insert into {{.TableName}}({{join .ColumnNames ", "}}) value ({{buildValueHold .ColumnNames}})"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}})
	if err != nil {
		return -1,err
	}
	return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) UpdateByPrimaryKey(primaryKey {{.PrimaryKeyType}},{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := repo.db.Exec("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? where {{.PrimaryKeyColumnName}} = ?"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}},primaryKey)
    if err != nil {
        return -1,err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) DeleteByPrimaryKey(primaryKey {{.PrimaryKeyType}}) (int64, error) {
    result, err := repo.db.Exec("delete from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return nil and err
// execute success but no record return nil and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) SelectByPrimaryKey(primaryKey {{.PrimaryKeyType}}) (*{{.EntityName}},error) {
	{{StrFirstLetterToLowercase .EntityName}} := new({{.EntityName}})
	err := repo.db.Get({{StrFirstLetterToLowercase .EntityName}}, "select {{join .ColumnNames ", "}} from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
	if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    return {{StrFirstLetterToLowercase .EntityName}}, nil
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) UpdateByExample(example *{{.EntityName}}Example,{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    criteria := example.criteria
    var params []interface{}

    {{range .ColumnNames}}params = append(params,{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}})
    {{end}}
    var condition = ""
    if len(criteria) > 0 {
        var fragments []string
        for _, e := range criteria {
            fragments = append(fragments, e.fragment)
            if !e.noValue {
                params = append(params, e.param1)
            }
            if e.betweenValue {
                params = append(params, e.param2)
            }
        }
        condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    }
    query, args, err := sqlx.In("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? "+condition, params...)
    if err != nil {
        return -1, err
    }
    result, err := repo.db.Exec(query, args...)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) DeleteByExample(example *{{.EntityName}}Example) (int64, error) {
	criteria := example.criteria
	var params []interface{}
	var condition = ""
	if len(criteria) > 0 {
		var fragments []string
		for _, e := range criteria {
			fragments = append(fragments, e.fragment)
			if !e.noValue {
				params = append(params, e.param1)
			}
			if e.betweenValue {
				params = append(params, e.param2)
			}
		}
		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
	}
	query, args, err := sqlx.In("delete from {{.TableName}} "+condition, params...)
	if err != nil {
		return -1, err
	}
	result, err := repo.db.Exec(query, args...)
	if err != nil {
		return -1, err
	}
	return result.RowsAffected()
}


// execute fail return empty slice and err
// execute success but no record return empty slice and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) SelectByExample(example *{{.EntityName}}Example) ([]*{{.EntityName}}, error) {
    var list []*{{.EntityName}}
    	criteria := example.criteria
    	var params []interface{}
    	var condition = ""
    	if len(criteria) > 0 {
    		var fragments []string
    		for _, e := range criteria {
    			fragments = append(fragments, e.fragment)
    			if !e.noValue {
                    params = append(params, e.param1)
                }
                if e.betweenValue {
                    params = append(params, e.param2)
                }
            }
    		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    	}
        query, args, err := sqlx.In("select {{join .ColumnNames ", "}} from {{.TableName}} "+condition, params...)
        if err != nil {
            return list,err
        }
    	return list, repo.db.Select(&list, query, args...)
}



