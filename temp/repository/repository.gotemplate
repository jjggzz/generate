// Code generated by sqlxgen. DO NOT EDIT.
package {{.PackageName}}

import (
    {{range .Imports}}{{.}}
    {{end}}
)

// 表名:{{.TableName}}
// comment:{{.EntityAnnotation}}
type {{ .EntityName}} struct {
	{{range .EntityFields}}{{.FieldName}} {{.FieldType}} `db:"{{.ColumnName}}" json:"{{StrFirstLetterToLowercase .FieldName}},omitempty"` // 字段: [{{.ColumnName}}] 类型:[{{.ColumnType}}] 注释: [{{.FieldAnnotation}}]
	{{end}}
}

func New{{.EntityName}}Repo(db *sqlx.DB) {{.EntityName}}Repository {
    return &{{StrFirstLetterToLowercase .EntityName}}Repo {
        db:db,
    }
}

type {{.EntityName}}Repository interface {
    Count() (int64, error)
    Insert(*{{.EntityName}}) (int64, error)
    UpdateByPrimaryKey({{.PrimaryKeyType}},*{{.EntityName}}) (int64, error)
    DeleteByPrimaryKey({{.PrimaryKeyType}}) (int64, error)
    SelectByPrimaryKey({{.PrimaryKeyType}}) (*{{.EntityName}}, error)
    UpdateByExample(*{{.EntityName}}Example,*{{.EntityName}}) (int64, error)
    DeleteByExample(*{{.EntityName}}Example) (int64, error)
    SelectByExample(*{{.EntityName}}Example) ([]*{{.EntityName}}, error)
}

type {{StrFirstLetterToLowercase .EntityName}}Repo struct {
    db *sqlx.DB
}

// execute fail return -1 and err
// execute success return count rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) Count() (int64, error) {
   var count int64
   	err := repo.db.Get(&count, "select count(*) from {{.TableName}}")
   	if err != nil {
   		return -1, err
   	}
   	return count,nil
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) Insert({{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := repo.db.Exec("insert into {{.TableName}}({{join .ColumnNames ", "}}) value ({{buildValueHold .ColumnNames}})"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}})
	if err != nil {
		return -1,err
	}
	return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) UpdateByPrimaryKey(primaryKey {{.PrimaryKeyType}},{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := repo.db.Exec("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? where {{.PrimaryKeyColumnName}} = ?"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}},primaryKey)
    if err != nil {
        return -1,err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) DeleteByPrimaryKey(primaryKey {{.PrimaryKeyType}}) (int64, error) {
    result, err := repo.db.Exec("delete from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return nil and err
// execute success but no record return nil and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) SelectByPrimaryKey(primaryKey {{.PrimaryKeyType}}) (*{{.EntityName}},error) {
	{{StrFirstLetterToLowercase .EntityName}} := new({{.EntityName}})
	err := repo.db.Get({{StrFirstLetterToLowercase .EntityName}}, "select {{join .ColumnNames ", "}} from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
	if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    return {{StrFirstLetterToLowercase .EntityName}}, nil
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) UpdateByExample(example *{{.EntityName}}Example,{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    criteria := example.criteria
    var params []interface{}

    {{range .ColumnNames}}params = append(params,{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}})
    {{end}}
    var condition = ""
    if len(criteria) > 0 {
        var fragments []string
        for _, e := range criteria {
            fragments = append(fragments, e.fragment)
            if !e.noValue {
                params = append(params, e.param1)
            }
            if e.betweenValue {
                params = append(params, e.param2)
            }
        }
        condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    }
    query, args, err := sqlx.In("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? "+condition, params...)
    if err != nil {
        return -1, err
    }
    result, err := repo.db.Exec(query, args...)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) DeleteByExample(example *{{.EntityName}}Example) (int64, error) {
	criteria := example.criteria
	var params []interface{}
	var condition = ""
	if len(criteria) > 0 {
		var fragments []string
		for _, e := range criteria {
			fragments = append(fragments, e.fragment)
			if !e.noValue {
				params = append(params, e.param1)
			}
			if e.betweenValue {
				params = append(params, e.param2)
			}
		}
		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
	}
	query, args, err := sqlx.In("delete from {{.TableName}} "+condition, params...)
	if err != nil {
		return -1, err
	}
	result, err := repo.db.Exec(query, args...)
	if err != nil {
		return -1, err
	}
	return result.RowsAffected()
}


// execute fail return empty slice and err
// execute success but no record return empty slice and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) SelectByExample(example *{{.EntityName}}Example) ([]*{{.EntityName}}, error) {
    var list []*{{.EntityName}}
    	criteria := example.criteria
    	var params []interface{}
    	var condition = ""
    	if len(criteria) > 0 {
    		var fragments []string
    		for _, e := range criteria {
    			fragments = append(fragments, e.fragment)
    			if !e.noValue {
                    params = append(params, e.param1)
                }
                if e.betweenValue {
                    params = append(params, e.param2)
                }
            }
    		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    	}
        query, args, err := sqlx.In("select {{join .ColumnNames ", "}} from {{.TableName}} "+condition, params...)
        if err != nil {
            return list,err
        }
    	return list, repo.db.Select(&list, query, args...)
}


type {{.EntityName}}Example struct {
	criteria []struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}
}

func (ex *{{$.EntityName}}Example) Clear() *{{$.EntityName}}Example {
	ex.criteria = []struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{}
	return ex
}

{{range .EntityFields}}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}IsNull() *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} is null", noValue:true})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}IsNotNull() *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} is not null", noValue:true})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}EqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} = ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotEqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} <> ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}GreaterThan(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} > ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}GreaterThanOrEqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} >= ?", param1: param})
	return ex
}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}LessThan(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} < ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}LessThanOrEqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} <= ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}In(param []{{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} in (?)", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotIn(param []{{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} not in (?)", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}Between(param1 {{.FieldType}}, param2 {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} between ? and ?", param1: param1,param2: param2,betweenValue:true})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotBetween(param1 {{.FieldType}}, param2 {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} not between ? and ?", param1: param1,param2: param2,betweenValue:true})
	return ex
}

{{if eq .FieldType "string"}}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}Like(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} like ?", param1: param})
	return ex
}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotLike(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} not like ?", param1: param})
	return ex
}
{{end}}

{{end}}