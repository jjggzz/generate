// Code generated by sqlxgen. DO NOT EDIT.
package {{.PackageName}}

import (
    {{range .Imports}}{{.}}
    {{end}}
)

// 表名:{{.TableName}}
// comment:{{.EntityAnnotation}}
type {{ .EntityName}} struct {
	{{range .EntityFields}}{{.FieldName}} {{.FieldType}} `db:"{{.ColumnName}}" json:"{{StrFirstLetterToLowercase .FieldName}},omitempty"` // 字段: [{{.ColumnName}}] 类型:[{{.ColumnType}}] 注释: [{{.FieldAnnotation}}]
	{{end}}
}

func New{{.EntityName}}Repo() {{.EntityName}}Repository {
    return &{{StrFirstLetterToLowercase .EntityName}}Repo {}
}

type {{.EntityName}}Repository interface {
    Count(*sqlx.DB) (int64, error)
    Insert(*sqlx.DB, *{{.EntityName}}) (int64, error)
    UpdateByExample(*sqlx.DB, *{{.EntityName}}Example,*{{.EntityName}}) (int64, error)
    DeleteByExample(*sqlx.DB, *{{.EntityName}}Example) (int64, error)
    SelectByExample(*sqlx.DB, *{{.EntityName}}Example) ([]*{{.EntityName}}, error){{if and (ne .PrimaryKeyType "") (ne .PrimaryKeyName "") }}
	UpdateByPrimaryKey(*sqlx.DB, {{.PrimaryKeyType}}, *{{.EntityName}}) (int64, error)
    DeleteByPrimaryKey(*sqlx.DB, {{.PrimaryKeyType}}) (int64, error)
    SelectByPrimaryKey(*sqlx.DB, {{.PrimaryKeyType}}) (*{{.EntityName}}, error)
	{{end}}
	TxCount(*sqlx.Tx) (int64, error)
    TxInsert(*sqlx.Tx, *{{.EntityName}}) (int64, error)
    TxUpdateByExample(*sqlx.Tx, *{{.EntityName}}Example,*{{.EntityName}}) (int64, error)
    TxDeleteByExample(*sqlx.Tx, *{{.EntityName}}Example) (int64, error)
    TxSelectByExample(*sqlx.Tx, *{{.EntityName}}Example) ([]*{{.EntityName}}, error){{if and (ne .PrimaryKeyType "") (ne .PrimaryKeyName "") }}
	TxUpdateByPrimaryKey(*sqlx.Tx, {{.PrimaryKeyType}}, *{{.EntityName}}) (int64, error)
    TxDeleteByPrimaryKey(*sqlx.Tx, {{.PrimaryKeyType}}) (int64, error)
    TxSelectByPrimaryKey(*sqlx.Tx, {{.PrimaryKeyType}}) (*{{.EntityName}}, error)
	{{end}}
}

type {{StrFirstLetterToLowercase .EntityName}}Repo struct {}

// execute fail return -1 and err
// execute success return count rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) Count(db *sqlx.DB) (int64, error) {
   var count int64
   	err := db.Get(&count, "select count(*) from {{.TableName}}")
   	if err != nil {
   		return -1, err
   	}
   	return count,nil
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) Insert(db *sqlx.DB, {{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := db.Exec("insert into {{.TableName}}({{join .ColumnNames ", "}}) value ({{buildValueHold .ColumnNames}})"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}})
	if err != nil {
		return -1,err
	}
	return result.RowsAffected()
}

{{if and (ne .PrimaryKeyType "") (ne .PrimaryKeyName "") }}
// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) UpdateByPrimaryKey(db *sqlx.DB, primaryKey {{.PrimaryKeyType}},{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := db.Exec("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? where {{.PrimaryKeyColumnName}} = ?"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}},primaryKey)
    if err != nil {
        return -1,err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) DeleteByPrimaryKey(db *sqlx.DB, primaryKey {{.PrimaryKeyType}}) (int64, error) {
    result, err := db.Exec("delete from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return nil and err
// execute success but no record return nil and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) SelectByPrimaryKey(db *sqlx.DB, primaryKey {{.PrimaryKeyType}}) (*{{.EntityName}},error) {
	{{StrFirstLetterToLowercase .EntityName}} := new({{.EntityName}})
	err := db.Get({{StrFirstLetterToLowercase .EntityName}}, "select {{join .ColumnNames ", "}} from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
	if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    return {{StrFirstLetterToLowercase .EntityName}}, nil
}
{{end}}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) UpdateByExample(db *sqlx.DB, example *{{.EntityName}}Example,{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    criteria := example.criteria
    var params []interface{}

    {{range .ColumnNames}}params = append(params,{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}})
    {{end}}
    var condition = ""
    if len(criteria) > 0 {
        var fragments []string
        for _, e := range criteria {
            fragments = append(fragments, e.fragment)
            if !e.noValue {
                params = append(params, e.param1)
            }
            if e.betweenValue {
                params = append(params, e.param2)
            }
        }
        condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    }
    query, args, err := sqlx.In("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? "+condition, params...)
    if err != nil {
        return -1, err
    }
    result, err := db.Exec(query, args...)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) DeleteByExample(db *sqlx.DB, example *{{.EntityName}}Example) (int64, error) {
	criteria := example.criteria
	var params []interface{}
	var condition = ""
	if len(criteria) > 0 {
		var fragments []string
		for _, e := range criteria {
			fragments = append(fragments, e.fragment)
			if !e.noValue {
				params = append(params, e.param1)
			}
			if e.betweenValue {
				params = append(params, e.param2)
			}
		}
		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
	}
	query, args, err := sqlx.In("delete from {{.TableName}} "+condition, params...)
	if err != nil {
		return -1, err
	}
	result, err := db.Exec(query, args...)
	if err != nil {
		return -1, err
	}
	return result.RowsAffected()
}


// execute fail return empty slice and err
// execute success but no record return empty slice and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) SelectByExample(db *sqlx.DB, example *{{.EntityName}}Example) ([]*{{.EntityName}}, error) {
    var list []*{{.EntityName}}
    	criteria := example.criteria
    	var params []interface{}
    	var condition = ""
    	if len(criteria) > 0 {
    		var fragments []string
    		for _, e := range criteria {
    			fragments = append(fragments, e.fragment)
    			if !e.noValue {
                    params = append(params, e.param1)
                }
                if e.betweenValue {
                    params = append(params, e.param2)
                }
            }
    		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    	}
        query, args, err := sqlx.In("select {{join .ColumnNames ", "}} from {{.TableName}} "+condition, params...)
        if err != nil {
            return list,err
        }
    	return list, db.Select(&list, query, args...)
}

// execute fail return -1 and err
// execute success return count rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxCount(tx *sqlx.Tx) (int64, error) {
   var count int64
   	err := tx.Get(&count, "select count(*) from {{.TableName}}")
   	if err != nil {
   		return -1, err
   	}
   	return count,nil
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxInsert(tx *sqlx.Tx, {{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := tx.Exec("insert into {{.TableName}}({{join .ColumnNames ", "}}) value ({{buildValueHold .ColumnNames}})"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}})
	if err != nil {
		return -1,err
	}
	return result.RowsAffected()
}

{{if and (ne .PrimaryKeyType "") (ne .PrimaryKeyName "") }}
// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxUpdateByPrimaryKey(tx *sqlx.Tx, primaryKey {{.PrimaryKeyType}},{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    result, err := tx.Exec("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? where {{.PrimaryKeyColumnName}} = ?"{{range .ColumnNames}},{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}}{{end}},primaryKey)
    if err != nil {
        return -1,err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxDeleteByPrimaryKey(tx *sqlx.Tx, primaryKey {{.PrimaryKeyType}}) (int64, error) {
    result, err := tx.Exec("delete from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return nil and err
// execute success but no record return nil and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxSelectByPrimaryKey(tx *sqlx.Tx, primaryKey {{.PrimaryKeyType}}) (*{{.EntityName}},error) {
	{{StrFirstLetterToLowercase .EntityName}} := new({{.EntityName}})
	err := tx.Get({{StrFirstLetterToLowercase .EntityName}}, "select {{join .ColumnNames ", "}} from {{.TableName}} where {{.PrimaryKeyColumnName}} = ?", primaryKey)
	if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    return {{StrFirstLetterToLowercase .EntityName}}, nil
}
{{end}}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxUpdateByExample(tx *sqlx.Tx, example *{{.EntityName}}Example,{{StrFirstLetterToLowercase .EntityName}} *{{.EntityName}}) (int64, error) {
    criteria := example.criteria
    var params []interface{}

    {{range .ColumnNames}}params = append(params,{{StrFirstLetterToLowercase $.EntityName}}.{{findMap . $.EntityFieldMap}})
    {{end}}
    var condition = ""
    if len(criteria) > 0 {
        var fragments []string
        for _, e := range criteria {
            fragments = append(fragments, e.fragment)
            if !e.noValue {
                params = append(params, e.param1)
            }
            if e.betweenValue {
                params = append(params, e.param2)
            }
        }
        condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    }
    query, args, err := sqlx.In("update {{.TableName}} set {{join .ColumnNames "=?, "}}=? "+condition, params...)
    if err != nil {
        return -1, err
    }
    result, err := tx.Exec(query, args...)
    if err != nil {
        return -1, err
    }
    return result.RowsAffected()
}

// execute fail return -1 and err
// execute success return affected rows and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxDeleteByExample(tx *sqlx.Tx, example *{{.EntityName}}Example) (int64, error) {
	criteria := example.criteria
	var params []interface{}
	var condition = ""
	if len(criteria) > 0 {
		var fragments []string
		for _, e := range criteria {
			fragments = append(fragments, e.fragment)
			if !e.noValue {
				params = append(params, e.param1)
			}
			if e.betweenValue {
				params = append(params, e.param2)
			}
		}
		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
	}
	query, args, err := sqlx.In("delete from {{.TableName}} "+condition, params...)
	if err != nil {
		return -1, err
	}
	result, err := tx.Exec(query, args...)
	if err != nil {
		return -1, err
	}
	return result.RowsAffected()
}


// execute fail return empty slice and err
// execute success but no record return empty slice and nil
// execute success has record return data and nil
func (repo *{{StrFirstLetterToLowercase .EntityName}}Repo) TxSelectByExample(tx *sqlx.Tx, example *{{.EntityName}}Example) ([]*{{.EntityName}}, error) {
    var list []*{{.EntityName}}
    	criteria := example.criteria
    	var params []interface{}
    	var condition = ""
    	if len(criteria) > 0 {
    		var fragments []string
    		for _, e := range criteria {
    			fragments = append(fragments, e.fragment)
    			if !e.noValue {
                    params = append(params, e.param1)
                }
                if e.betweenValue {
                    params = append(params, e.param2)
                }
            }
    		condition += "where " + strings.TrimLeft(strings.Join(fragments, " "), "and")
    	}
        query, args, err := sqlx.In("select {{join .ColumnNames ", "}} from {{.TableName}} "+condition, params...)
        if err != nil {
            return list,err
        }
    	return list, tx.Select(&list, query, args...)
}


type {{.EntityName}}Example struct {
	criteria []struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}
}

func (ex *{{$.EntityName}}Example) Clear() *{{$.EntityName}}Example {
	ex.criteria = []struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{}
	return ex
}

{{range .EntityFields}}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}IsNull() *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} is null", noValue:true})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}IsNotNull() *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} is not null", noValue:true})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}EqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} = ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotEqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} <> ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}GreaterThan(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} > ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}GreaterThanOrEqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} >= ?", param1: param})
	return ex
}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}LessThan(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} < ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}LessThanOrEqualTo(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} <= ?", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}In(param []{{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} in (?)", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotIn(param []{{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} not in (?)", param1: param})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}Between(param1 {{.FieldType}}, param2 {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} between ? and ?", param1: param1,param2: param2,betweenValue:true})
	return ex
}

func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotBetween(param1 {{.FieldType}}, param2 {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} not between ? and ?", param1: param1,param2: param2,betweenValue:true})
	return ex
}

{{if eq .FieldType "string"}}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}Like(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} like ?", param1: param})
	return ex
}
func (ex *{{$.EntityName}}Example) And{{.FieldName}}NotLike(param {{.FieldType}}) *{{$.EntityName}}Example {
	ex.criteria = append(ex.criteria, struct {
		fragment     string
		param1       interface{}
		param2       interface{}
		noValue      bool
		betweenValue bool
	}{fragment: "and {{.ColumnName}} not like ?", param1: param})
	return ex
}
{{end}}

{{end}}